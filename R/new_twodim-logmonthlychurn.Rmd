---
title: "Churn: Two dimensions and predict log of monthly churn probability"
output: html_notebook
---

```{r setup, include=FALSE}
source('config.R')
source('utils.R')
source('utils_validation.R')

# sampling for dev
# SAMPLE_DATA <- TRUE
SAMPLE_DATA <- FALSE
fraction_sample <- 0.01 # use this to slim data for faster experimentation

# source('new_lifetimepredictor.R')
```

Getting the data

```{r reading, tidy=F}
# don't read again, we've already got it
if (!exists('customers_org')){
  readData(customers_file, subscriptions_file, gdp_file)
}
```

Optionally sample the data for faster development

```{r customers_processing, tidy=F}
customers <- customers_org %>%
  processCustomers(SAMPLE_DATA, fraction_sample)
```

```{r subscriptions_processing, tidy=F}

subscriptions <- subscriptions_org %>%
  # Removing customers not in the customers set
  filter(customerid %in% customers$customerid) %>%

  processSubscriptions() %>%

  joinProcessCustomers(customers, age_to_join_sitevers = 5) %>%

  joinProcessGDP(gdp) %>%

  concatCategrories() %>%

  mutate_if(is.character, funs(as.factor))
  
```

```{r}
summary(subscriptions)
```

```{r}
subscriptions_with_target <- subscriptions %>%
  # restrict to a recent expiry window
  filter(endmonth >= begin_train_window & endmonth < end_window) %>%
  mutate(num_previous_months_binned_fct = as.factor(num_previous_months_binned)) %>%
  mutate(set_type = as.factor(if_else(endmonth >= begin_validation_window, 'validation', 'training'))) %>%
  
  mutate(churnind = ifelse(status == 'churn', 1, 0)) 
```


Prepare churntable that we want to predicdt

```{r}
churntable <- subscriptions_with_target %>%
  
  group_by(set_type, siteverkey_cat2, market_category, months, num_previous_months_binned, chosen_subs_length, subscription_summary_no_market) %>%
  summarise(num_obs = n(), 
            churned = sum(churnind)) %>%
  
  group_by(set_type) %>%
  mutate(churn_rate = churned / num_obs,
         renew_rate = 1 - churn_rate,
         month_churn = 1 - renew_rate ^ (1/as.double(months)),
         log_month_churn = log(month_churn),
         weight = num_obs / sum(num_obs))

# NB! Does this introduce a bad bias ????
churntable_no_zeros <- churntable %>%
  filter(churn_rate > 0)
```

```{r}
summary(churntable)
```
```{r}
summary(churntable_no_zeros)
```


Calculate model

```{r}
new_model=glm(log_month_churn ~ market_category + subscription_summary_no_market, data=churntable_no_zeros[churntable_no_zeros$set_type == 'training', ], weights = weight)
summary(new_model)

anova(new_model, test="Chisq")
```

Validate

```{r}
model_validation <- validation(subscriptions_with_target, new_model, predict_2fct_model)

model_validation$summary_table
```

```{r}
model_validation$roc_plot
```

```{r results='hide',fig.keep='all'}
model_validation$calibration_plots
```

```{r results='hide',fig.keep='all'}
model_validation$real_churn_plot
```

Try simple logistic model
```{r}
model_logit <- glm(churnind ~ market_category + siteverkey_cat2 + num_previous_months_binned + months + chosen_subs_length,
                   data = subscriptions_with_target[subscriptions_with_target$set_type == 'training',], family = 'binomial')
summary(model_logit)
```

Validate
```{r}
model_validation_logit <- validation(subscriptions_with_target, model_logit)
model_validation_logit$summary_table
```

```{r}
model_validation_logit$roc_plot
```
```{r results='hide',fig.keep='all'}
model_validation_logit$calibration_plots
```
```{r results='hide',fig.keep='all'}
model_validation_logit$real_churn_plot
```


